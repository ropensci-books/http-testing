# Graceful HTTP R packages

Based on the previous chapter, your package interacting with a web resource has a dependency on `{curl}`, `{httr}` or `{crul}`. You have hopefully read the docs of the dependency you chose, including, in the case of httr and crul, the vignette about best practice for HTTP packages. Now, in this chapter we want to give more tips aimed at making your HTTP R package graceful, part of which you'll learn more about in this very book!

**Why** write a *graceful* HTTP R package? First of all, graceful is a nice adjective. ðŸ’ƒðŸ•ºThen, graceful is the adjective used in [CRAN repository policy](https://cran.r-project.org/web/packages/policies.html) *"Packages which use Internet resources should fail gracefully with an informative message if the resource is not available or has changed (and not give a check warning nor error)."* Therefore, let's review how to make your R package graceful from this day forward, in success and in failure.

## Choose the HTTP resource wisely

First of all,your life and the life of your package's users will be easier if the web service you're wrapping is well maintained and well documented. When you have a choice, try not to rely on a fragile web service. Moreover, if you can, try to communicate with the API providers (telling them about your package; reporting feature requests and bug reports in their preferred way).

## User-facing grace (how your package actually works)

0.  If you can do not request the API every time the user asks for something but cache data instead. No API call, no API call failure! ðŸ˜‰ To remember answers within a session check out [memoise](<https://github.com/r-lib/memoise>). To remember answers across sessions, see [webmiddens](https://docs.ropensci.org/webmiddens/), and approaches presented in the R-hub blog post ["Persistent config and data for R packages"](<https://blog.r-hub.io/2020/03/12/user-preferences/>)

1.  Try to send correct requests by knowing what the API expects and validating user inputs; at the correct rate. For instance, don't even try interacting with a web API requiring authentication if the user does not provide authentication information. For limiting rate i.e. not sending too many requests, automatically wait or, if the API docs allow you to define an ideal or maximal rate, set the request rate in advance using the \`{ratelimir}\` package.

2.  If there's a status API i.e. a separate API indicating whether the web resource is up or down, use it. If it tells you the API is down, \`stop()\` with an informative error message.

3.  If the API indicates an error, depending on the actual error,

    -   If the *server* seems to be having issues, [re-try with an exponential back-off](<https://blog.r-hub.io/2020/04/07/retry-wheel/>).

    -    Otherwise, [transform the error into an useful error](https://httr.r-lib.org/articles/api-packages.html#turn-api-errors-into-r-errors-1).

    -   If you used retry and nothing was sent after the maximal number of retries, have an informative error message.

That was it for aspects the user will care about. Now, what might be more problematic for your package's fate on CRAN are the automatic checks that happen there at submission and then regularly.

## Graceful vignettes and examples

4.  Pre-compute vignettes in some way. Don't use them as tests, they are a showcase (but of course have a system to prevent them from going stale, maybe even simple reminders). Don't let them run on a system where a failure has bad consequences. <https://blog.r-hub.io/2020/06/03/vignettes/>
5.  Don't run examples. <https://blog.r-hub.io/2020/01/27/examples/>

## Tests

6.  In tests, do like 0. Use fixtures. Read the HTTP testing book.
7.  Test for behavior in case of server failures :stuck\_out\_tongue\_winking\_eye:

But really CRAN's policy is mostly about vignettes, examples and tests, since your code won't be reviewed.
